import React, { useMemo, useState, useEffect, useRef } from 'react';
import {
  BarChart, Bar, XAxis, YAxis, Legend, CartesianGrid, Tooltip,
  ComposedChart, Area, Line, ReferenceLine,
  AreaChart, RadarChart, PolarGrid, PolarAngleAxis, PolarRadiusAxis, Radar, ReferenceArea, ScatterChart, Scatter, ZAxis, Cell, LineChart, Pie, ResponsiveContainer
} from 'recharts';
import BaseChart from './BaseChart';
import { chartConfig, getGridColor, getTooltipStyle } from './ChartConfig';
import { Activity, BarChart2, Mountain, Zap, BrainCircuit, Pickaxe, Hexagon, TrendingUp, Anchor, Target, CircleDot, PieChart, RotateCw, Smile, Battery, TrendingDown, Scale, Compass, Layers, GitMerge, Shield, Eye, CheckCircle2, Clock, GripVertical, HelpCircle, Square, ArrowRight, Search, BookOpen, Repeat, FileSearch, Lightbulb, RefreshCw, Timer, Star, FileText, MessageCircle, User, ArrowLeftRight, Layout, Diamond } from 'lucide-react';
import { Theme, Project, Habit } from '../types';
import { DndContext, closestCenter, KeyboardSensor, PointerSensor, useSensor, useSensors, DragEndEvent } from '@dnd-kit/core';
import { arrayMove, SortableContext, sortableKeyboardCoordinates, verticalListSortingStrategy, horizontalListSortingStrategy, useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import GlobalGuideCard from './HelpSystem/HelpModal';
import { helpContent } from './HelpSystem/HelpContent';

interface MissionControlProps {
  theme: Theme;
  projects: Project[];
  habits: Habit[];
}

const MissionControl: React.FC<MissionControlProps> = ({ theme, projects, habits }) => {
  const isDark = theme === 'dark';
  const isNeomorphic = theme === 'neomorphic';
  
  // 拟态风格样式变量 - 优化阴影效果，使其与按钮圆角匹配
  const neomorphicStyles = {
    bg: 'bg-[#e0e5ec]',
    border: 'border-[#e0e5ec]',
    shadow: 'shadow-[8px_8px_16px_rgba(163,177,198,0.2),-8px_-8px_16px_rgba(255,255,255,0.8)] rounded-[24px]',
    hoverShadow: 'hover:shadow-[10px_10px_20px_rgba(163,177,198,0.3),-10px_-10px_20px_rgba(255,255,255,0.9)] rounded-[24px]',
    activeShadow: 'active:shadow-[inset_5px_5px_10px_rgba(163,177,198,0.3),inset_-5px_-5px_10px_rgba(255,255,255,0.8)] rounded-[24px]',
    transition: 'transition-all duration-200'
  };
  
  const bgClass = isDark ? 'bg-zinc-950' : isNeomorphic ? 'bg-[#e0e5ec]' : 'bg-slate-50';
  const cardBg = isDark 
      ? 'bg-zinc-900' 
      : isNeomorphic 
      ? `${neomorphicStyles.bg} rounded-[48px] ${neomorphicStyles.shadow} ${neomorphicStyles.hoverShadow} ${neomorphicStyles.activeShadow} ${neomorphicStyles.transition}` 
      : 'bg-white shadow-sm';
  const textMain = isDark ? 'text-zinc-200' : isNeomorphic ? 'text-zinc-700' : 'text-slate-800';
  const textSub = isDark ? 'text-zinc-500' : isNeomorphic ? 'text-zinc-600' : 'text-slate-500';

  const [activeChart, setActiveChart] = useState<string>('systemFeedback');
  // 确保图表在页面加载时显示系统反馈模型
  const [chartHeight, setChartHeight] = useState<number>(600);
  const [activeHelp, setActiveHelp] = useState<string | null>(null);
  const chartContainerRef = useRef<HTMLDivElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  
  // 默认指南卡片配置
  const guideCardConfig = {
    fontSize: 'medium' as const,
    borderRadius: 'medium' as const,
    shadowIntensity: 'medium' as const,
    showUnderlyingPrinciple: true
  };

  // Drag and Drop state - 删除习惯完成率和专注时间趋势，添加新的成长型思维、沉没成本谬误和二八定律，以及新增的决策/行为/认知/学习类图表
  const [chartCategories, setChartCategories] = useState<{ [key: string]: string[] }>({
    trend: ['dip', 'dunning', 'jcurve', 'antifragile', 'secondcurve', 'compound', 'dopamine', 'flow'],
    concept: ['zone', 'woop', 'peakEnd', 'valueVenn', 'purpose', 'johariWindow', 'footInDoor', 'deliberatePractice', 'foggBehavior', 'eisenhowerMatrix', 'growthMindset', 'sunkCost', 'pareto', 'swot', 'goldenCircle', 'fiveWhys', 'brokenWindow', 'matthewEffect', 'hedgehogPrinciple', 'survivorshipBias', 'occamsRazor', 'anchoringEffect', 'tenThousandHours', 'feynmanTechnique', 'spacedRepetition', 'probabilityThinking', 'regretMinimization', 'identityTheory', 'zeigarnikEffect', 'grayThinking', 'reverseThinking', 'riaReading', 'feedbackLoop', 'eisenhowerAdvanced', 'energyManagement', 'prospectTheory', 'weightedDecisionMatrix', 'feedbackPeakLaw', 'environmentDesign', 'frameRefactoring', 'knowledgeCrystallization', 'metaLearning', 'crossDomainLearning', 'energySegmentation', 'smartPrinciple']
  });

  // Load saved categories from localStorage
  useEffect(() => {
    const savedCategories = localStorage.getItem('chartCategories');
    const initialCategories = {
      trend: ['dip', 'dunning', 'jcurve', 'antifragile', 'secondcurve', 'compound', 'dopamine', 'flow'],
      concept: ['zone', 'woop', 'peakEnd', 'valueVenn', 'purpose', 'johariWindow', 'footInDoor', 'deliberatePractice', 'foggBehavior', 'eisenhowerMatrix', 'growthMindset', 'sunkCost', 'pareto', 'swot', 'goldenCircle', 'fiveWhys', 'brokenWindow', 'matthewEffect', 'hedgehogPrinciple', 'survivorshipBias', 'occamsRazor', 'anchoringEffect', 'tenThousandHours', 'feynmanTechnique', 'spacedRepetition', 'probabilityThinking', 'regretMinimization', 'identityTheory', 'zeigarnikEffect', 'grayThinking', 'reverseThinking', 'riaReading', 'feedbackLoop', 'eisenhowerAdvanced', 'energyManagement', 'prospectTheory', 'weightedDecisionMatrix', 'feedbackPeakLaw', 'environmentDesign', 'frameRefactoring', 'knowledgeCrystallization', 'metaLearning', 'crossDomainLearning', 'energySegmentation', 'smartPrinciple']
    };
    
    if (savedCategories) {
      // Merge saved categories with initial categories to ensure all charts are included
      const parsedCategories = JSON.parse(savedCategories);
      const mergedCategories = {
        trend: [...new Set([...initialCategories.trend, ...(parsedCategories.trend || [])])].filter(id => !['habitCompletion', 'focusTrend'].includes(id)),
        concept: [...new Set([...initialCategories.concept, ...(parsedCategories.concept || [])])]
      };
      setChartCategories(mergedCategories);
    }
  }, []);

  // Save categories to localStorage
  useEffect(() => {
    localStorage.setItem('chartCategories', JSON.stringify(chartCategories));
  }, [chartCategories]);

  // Initialize sensors for drag and drop
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 5, // Reduced distance for mobile touch
      },
    }),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  // Enable touch action for draggable elements
  useEffect(() => {
    const draggableElements = document.querySelectorAll('[draggable="true"]');
    draggableElements.forEach(element => {
      (element as HTMLElement).style.touchAction = 'none';
    });
    
    return () => {
      draggableElements.forEach(element => {
        (element as HTMLElement).style.touchAction = '';
      });
    };
  }, []);

  // Create a SortableButton component using useSortable hook
  const SortableButton = React.memo(({ id, chart }: { id: string; chart: any }) => {
    const { attributes, listeners, setNodeRef, transform, isDragging } = useSortable({ id });

    const handleClick = (e: React.MouseEvent<HTMLDivElement>) => {
      e.stopPropagation();
      setActiveChart(id);
    };

    // Create smooth animation styles for dragging
    const style = {
      transform: CSS.Transform.toString(transform),
      transition: isDragging ? 'transform 0.1s ease-out' : 'transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out',
      opacity: isDragging ? 0.5 : 1,
      zIndex: isDragging ? 1000 : 'auto',
      scale: isDragging ? 1.05 : 1,
      cursor: 'pointer' // 整个按钮区域都显示指针图标
    };

    return (
      <div
        ref={setNodeRef}
        className={`flex items-center px-4 py-2 rounded-2xl text-xs font-bold transition-all duration-300 ${getButtonClass(activeChart === id)} hover:scale-105 hover:shadow-lg transform hover:-translate-y-0.5`}
        style={style}
        {...attributes}
        onClick={handleClick} // 将点击事件移到外层div，确保整个按钮区域都可以点击
      >
        {/* Drag handle - only this part handles drag events */}
        <span
          className="cursor-move hover:text-blue-500 transition-colors flex-shrink-0"
          {...listeners}
          style={{ zIndex: 1 }} // 确保拖动手柄在最上层
        >
          <GripVertical size={10} className="mr-1 text-zinc-500" />
        </span>
        
        {/* Button content - no longer needs separate button element */}
        <div className="flex items-center gap-1 flex-grow">
          <chart.icon size={12}/> {chart.label}
        </div>
      </div>
    );
  });

  // Handle drag end event
  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event;

    if (!over) return;

    const activeId = active.id as string;
    const overId = over.id as string;

    if (activeId === overId) return;

    // Determine source and destination categories
    let sourceCategory: string | null = null;
    let destCategory: string | null = null;

    for (const [category, charts] of Object.entries(chartCategories)) {
      const chartArray = charts as string[];
      if (chartArray.includes(activeId)) {
        sourceCategory = category;
      }
      if (chartArray.includes(overId) || overId === `category-${category}`) {
        destCategory = overId === `category-${category}` ? category : category;
      }
    }

    if (!sourceCategory || !destCategory) return;

    // Create new categories object
    const newCategories = { ...chartCategories };

    // Remove activeId from source category
    newCategories[sourceCategory] = newCategories[sourceCategory].filter(id => id !== activeId);

    // Find index to insert in destination category
    let insertIndex: number;
    if (overId.startsWith('category-')) {
      // Insert at the beginning of the category
      insertIndex = 0;
    } else {
      // Insert after overId in destination category
      insertIndex = newCategories[destCategory].indexOf(overId) + 1;
    }

    // Add activeId to destination category
    newCategories[destCategory] = [
      ...newCategories[destCategory].slice(0, insertIndex),
      activeId,
      ...newCategories[destCategory].slice(insertIndex)
    ];

    setChartCategories(newCategories);
  };

  // Get chart by id
  const getChartById = (id: string) => {
    return CHARTS.find(chart => chart.id === id);
  };

  // Chart rendering function to avoid complex nested conditional rendering
  const renderChart = () => {
    const activeChartObj = getChartById(activeChart);
    
    switch (activeChart) {
      case 'attributeRadar':
        // 暂时禁用该图表，因为 attributeData 未定义
        return (
          <BaseChart data={[]} isDark={isDark}>
            <div className="flex items-center justify-center h-full">
              <p className={isDark ? 'text-gray-400' : 'text-gray-500'}>该图表暂不可用</p>
            </div>
          </BaseChart>
        );
      case 'focusHeatmap':
        // 暂时禁用该图表，因为 dailyFocusData 未定义
        return (
          <BaseChart data={[]} isDark={isDark} >
            <div className="flex items-center justify-center h-full">
              <p className={isDark ? 'text-gray-400' : 'text-gray-500'}>该图表暂不可用</p>
            </div>
          </BaseChart>
        );
      case 'entropy':
        // 暂时禁用该图表，因为 entropyData 未定义
        return (
          <BaseChart data={[]} isDark={isDark} height={chartHeight}>
            <div className="flex items-center justify-center h-full">
              <p className={isDark ? 'text-gray-400' : 'text-gray-500'}>该图表暂不可用</p>
            </div>
          </BaseChart>
        );
      default:
        return (
          <BaseChart data={[]} isDark={isDark} height={chartHeight}>
            <div className="flex items-center justify-center h-full">
              <p className={isDark ? 'text-gray-400' : 'text-gray-500'}>选择一个图表开始探索</p>
            </div>
          </BaseChart>
        );
    }
  };

  // Get button class based on active state
  const getButtonClass = (isActive: boolean) => {
    if (isActive) {
      return isDark ? 'bg-blue-600 text-white' : isNeomorphic ? 'bg-blue-500 text-white' : 'bg-blue-500 text-white';
    }
    return isDark ? 'bg-zinc-800 text-zinc-300' : isNeomorphic ? 'bg-white/70 text-zinc-700' : 'bg-white text-slate-700';
  };

  return (
    <div className={`w-full h-full ${bgClass} overflow-auto`} ref={containerRef}>
      {/* Chart Categories */}
      <div className="p-4">
        <h2 className={`text-xl font-bold mb-4 ${textMain}`}>思维模型与图表系统</h2>
        
        {/* Chart Navigation */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
          {Object.entries(chartCategories).map(([category, charts]) => (
            <div key={category}>
              <h3 className={`text-sm font-semibold mb-2 ${textSub}`}>
                {category === 'trend' ? '趋势模型' : '概念模型'}
              </h3>
              <div className="flex flex-wrap gap-2">
                {charts.map((chartId, index) => {
                  const chart = getChartById(chartId);
                  if (!chart) return null;
                  return (
                    <button
                      key={chartId}
                      className={`px-3 py-1.5 rounded-full text-xs font-medium transition-all duration-200 ${getButtonClass(activeChart === chartId)} hover:scale-105 hover:shadow-md`}
                      onClick={() => setActiveChart(chartId)}
                    >
                      <chart.icon size={12} className="inline-block mr-1" />
                      {chart.label}
                    </button>
                  );
                })}
              </div>
            </div>
          ))}
        </div>
      </div>

      {/* Main Chart Area */}
      <div className={`flex flex-col gap-4 ${bgClass}`} ref={chartContainerRef}>
        <div className={`${cardBg} p-6 rounded-3xl shadow-lg`}>
          {/* Chart Title */}
          <div className="flex justify-between items-center mb-6">
            <h3 className={`text-2xl font-bold ${textMain}`}>
              {getChartById(activeChart)?.label || '思维模型'}
            </h3>
            <button
              className={`p-2 rounded-full hover:bg-blue-500/10 transition-colors ${textSub}`}
              onClick={() => setActiveHelp(activeChart)}
            >
              <HelpCircle size={20} />
            </button>
          </div>
          
          {/* Chart Content */}
          <div className="w-full h-[600px] bg-white/90 dark:bg-zinc-800/90 rounded-2xl shadow-inner p-4">
            {renderChart()}
          </div>
        </div>
      </div>

      {/* Help Modal */}
      <GlobalGuideCard
        isOpen={!!activeHelp}
        onClose={() => setActiveHelp(null)}
        content={helpContent[activeHelp as keyof typeof helpContent] || {}}
        config={guideCardConfig}
        theme={theme}
      />
    </div>
  );
};

export default MissionControl;